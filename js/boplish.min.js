(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*global navigator, document, console, window */

/**
 * @fileOverview
 * <p>
 * Adapter code for handling browser differences.
 * </p>
 * <p>
 * Original version retrieved from <a href="https://apprtc.appspot.com/js/adapter.js">https://apprtc.appspot.com/js/adapter.js</a>.
 * </p>
 */

RTCPeerConnection = null;
getUserMedia = null;
attachMediaStream = null;
reattachMediaStream = null;
webrtcDetectedBrowser = null;
webrtcDetectedVersion = null;

if (typeof(navigator) !== 'undefined' && navigator.mozGetUserMedia) {
    console.log("This appears to be Firefox");

    webrtcDetectedBrowser = "firefox";

    webrtcDetectedVersion =
        parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);

    // The RTCPeerConnection object.
    RTCPeerConnection = mozRTCPeerConnection;

    // The RTCSessionDescription object.
    RTCSessionDescription = mozRTCSessionDescription;

    // The RTCIceCandidate object.
    RTCIceCandidate = mozRTCIceCandidate;

    // Get UserMedia (only difference is the prefix).
    // Code from Adam Barth.
    getUserMedia = navigator.mozGetUserMedia.bind(navigator);

    // Creates iceServer from the url for FF.
    createIceServer = function(url, username, password) {
        var iceServer = null;
        var url_parts = url.split(':');
        if (url_parts[0].indexOf('stun') === 0) {
            // Create iceServer with stun url.
            iceServer = {
                'url': url
            };
        } else if (url_parts[0].indexOf('turn') === 0 &&
            (url.indexOf('transport=udp') !== -1 ||
                url.indexOf('?transport') === -1)) {
            // Create iceServer with turn url.
            // Ignore the transport parameter from TURN url.
            var turn_url_parts = url.split("?");
            iceServer = {
                'url': turn_url_parts[0],
                'credential': password,
                'username': username
            };
        }
        return iceServer;
    };

    // Attach a media stream to an element.
    attachMediaStream = function(element, stream) {
        console.log("Attaching media stream");
        element.mozSrcObject = stream;
        element.play();
    };

    reattachMediaStream = function(to, from) {
        console.log("Reattaching media stream");
        to.mozSrcObject = from.mozSrcObject;
        to.play();
    };

    // Fake get{Video,Audio}Tracks
    MediaStream.prototype.getVideoTracks = function() {
        return [];
    };

    MediaStream.prototype.getAudioTracks = function() {
        return [];
    };
} else if (typeof(navigator) !== 'undefined' && navigator.webkitGetUserMedia) {
    console.log("This appears to be Chrome");

    webrtcDetectedBrowser = "chrome";
    webrtcDetectedVersion =
        parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);

    // Creates iceServer from the url for Chrome.
    createIceServer = function(url, username, password) {
        var iceServer = null;
        var url_parts = url.split(':');
        if (url_parts[0].indexOf('stun') === 0) {
            // Create iceServer with stun url.
            iceServer = {
                'url': url
            };
        } else if (url_parts[0].indexOf('turn') === 0) {
            if (webrtcDetectedVersion < 28) {
                // For pre-M28 chrome versions use old TURN format.
                var url_turn_parts = url.split("turn:");
                iceServer = {
                    'url': 'turn:' + username + '@' + url_turn_parts[1],
                    'credential': password
                };
            } else {
                // For Chrome M28 & above use new TURN format.
                iceServer = {
                    'url': url,
                    'credential': password,
                    'username': username
                };
            }
        }
        return iceServer;
    };

    // The RTCPeerConnection object.
    RTCPeerConnection = webkitRTCPeerConnection;

    // Get UserMedia (only difference is the prefix).
    // Code from Adam Barth.
    getUserMedia = navigator.webkitGetUserMedia.bind(navigator);

    // Attach a media stream to an element.
    attachMediaStream = function(element, stream) {
        if (typeof element.srcObject !== 'undefined') {
            element.srcObject = stream;
        } else if (typeof element.mozSrcObject !== 'undefined') {
            element.mozSrcObject = stream;
        } else if (typeof element.src !== 'undefined') {
            element.src = URL.createObjectURL(stream);
        } else {
            console.log('Error attaching stream to element.');
        }
    };

    reattachMediaStream = function(to, from) {
        to.src = from.src;
    };

    // The representation of tracks in a stream is changed in M26.
    // Unify them for earlier Chrome versions in the coexisting period.
    if (!webkitMediaStream.prototype.getVideoTracks) {
        webkitMediaStream.prototype.getVideoTracks = function() {
            return this.videoTracks;
        };
        webkitMediaStream.prototype.getAudioTracks = function() {
            return this.audioTracks;
        };
    }

    // New syntax of getXXXStreams method in M26.
    if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
        webkitRTCPeerConnection.prototype.getLocalStreams = function() {
            return this.localStreams;
        };
        webkitRTCPeerConnection.prototype.getRemoteStreams = function() {
            return this.remoteStreams;
        };
    }
} else {
    console.log("Browser does not appear to be WebRTC-capable");
}

},{}],2:[function(require,module,exports){
(function (process){
/** @fileOverview API for application developers. */

var ConnectionManager = require('./connectionmanager.js');
var Router = require('./router.js');
var sha1 = require('./third_party/sha1.js');

/**
 * @constructor
 * @class This is the top-level API for BOPlish applications. It should be the
 * only interface used for interacting with the P2P network.
 * @param bootstrapHost {String} Name and port of the host running the signaling
 * server. The format is 'ws[s]://HOSTNAME[:PORT][/]'. If this is undefined or null then
 * the host of the serving application is used. Using the `wss` scheme for tls encrypted
 * communication to the `bootstrapHost` is highly recommended.
 * @param successCallback {BOPlishClient~onSuccessCallback} Called when a
 * connection to the P2P network has been established.
 * @param errorCallback {BOPlishClient~onErrorCallback} Called when a connection
 * to the P2P network could not be established (e.g. if the WebSocket connection
 * to the bootstrapHost failed.
 */
BOPlishClient = function(bootstrapHost, successCallback, errorCallback) {
    var browser = this.utils.whatBrowserAmI();
    if (browser.vendor === 'Firefox' && Number(browser.version.slice(0, 2)) >= 26) {
        // we are on FF
    } else if (browser.vendor === 'Chrome' && Number(browser.version.slice(0, 2)) >= 33) {
        // we are on Chrome
    } else if (browser.vendor === 'Node.js') {
        // we are on Node.js
    } else {
        errorCallback('You will not be able to use BOPlish as your browser is currently incompatible. Please use either Firefox 26 or Chrome 33 upwards.');
        return;
    }

    var hash = new sha1();
    hash.update(Math.random().toString());
    this.id = sha1.hexString(hash.digest());

    if (bootstrapHost.substring(bootstrapHost.length - 1, bootstrapHost.length) !== '/') { // add trailing slash if missing
        bootstrapHost += '/';
    }
    if (bootstrapHost.substring(0, 6) !== 'wss://' && bootstrapHost.substring(0, 5) !== 'ws://') { // check syntax
        errorCallback('Syntax error in bootstrapHost parameter');
        return;
    }
    var channel = new WebSocket(bootstrapHost + 'ws/' + this.id);

    channel.onerror = function(ev) {
        errorCallback('Failed to open connection to bootstrap server:' + bootstrapHost + ': ' + ev);
    };

    channel.onopen = function() {
        this._connectionManager.bootstrap(this._router, successCallback, errorCallback);
    }.bind(this);

    this._connectionManager = new ConnectionManager(channel);
    this._router = new Router(this.id, channel, this._connectionManager);
};

BOPlishClient.prototype = {

    utils: {
        /**
         * Returns an object with information about the browser in use
         */
        whatBrowserAmI: function() {
            if (typeof(process) !== 'undefined' && typeof(module) !== 'undefined') {
                return {
                    vendor: 'Node.js',
                    version: process.version
                };
            }
            // source http://stackoverflow.com/questions/5916900/detect-version-of-browser
            var ua = navigator.userAgent,
                N = navigator.appName,
                tem,
                M = ua.match(/(opera|chrome|safari|firefox|msie|trident)\/?\s*([\d\.]+)/i) || [];
            M = M[2] ? [M[1], M[2]] : [N, navigator.appVersion, '-?'];
            if (M && (tem = ua.match(/version\/([\.\d]+)/i)) !== null) {
                M[2] = tem[1];
            }
            return {
                vendor: M[0],
                version: M[1]
            };
        }
    },
    /**
     * Sends a message to the given peer.
     * @param to {String} Receiver of the message
     * @param protocol {String} Protocol name. On the receiver side a handler
     * has to be installed for this protocol.
     * @param payload {Object} The payload to send.
     */
    send: function(to, protocol, payload) {
        this._router.route(to, protocol, payload);
    },
    /**
     * Installs a handler for the given protocol name.
     * @param protocol {String} The protocol to handle.
     * @param callback {BOPlishClient~onMessageCallback} The function invoked when a message of the
     * given protocol is received through the P2P network.
     */
    setOnMessageHandler: function(protocol, callback) {
        this._router.registerDeliveryCallback(protocol, callback);
    },
    /**
     * Installs a special callback that receives all messages despite their
     * protocol.
     * @param callback {BOPlishClient~monitorCallback} Invoked on reception of a
     * message.
     */
    setMonitorCallback: function(callback) {
        this._router.registerMonitorCallback(callback);
    },
    /**
     * @return {Array} The list of all IDs of peers this peer has an open
     * connection to.
     */
    getConnectedPeers: function() {
        return this._router.getPeerIds();
    }
};

/**
 * Invoked when a message is received.
 * @callback BOPlishClient~onMessageCallback
 * @param from {String} The sender's ID
 * @param payload {Object} The message object in JSON format.
 */

/**
 * Invoked when a connection to the P2P network has been established.
 * @callback BOPlishClient~onSuccessCallback
 */

/**
 * Invoked when a connection to the P2P network could not be established.
 * @callback BOPlishClient~onErrorCallback
 */

/**
 * Invoked when a message has been received. Useful for monitoring the complete
 * traffic passing in/out of this peer.
 * @callback BOPlishClient~monitorCallback
 * @param message {Object} The raw message in router format.
 */

if (typeof(module) !== 'undefined') {
    module.exports = BOPlishClient;
}

}).call(this,require("FWaASH"))
},{"./connectionmanager.js":6,"./router.js":8,"./third_party/sha1.js":10,"FWaASH":11}],3:[function(require,module,exports){
/** @fileOverview URI parsing functionality for BOPlish URIs */

/**
 * @constructor
 * @class BOPlish URI class. Parses BOPlish URIs and allows access to the
 * different components.
 *
 * @param str the URI string to parse
 */
var BopURI = function(str) {

    if (!(this instanceof BopURI)) {
        return new BopURI(str);
    }

    var pathSepIdx = str.indexOf('/');
    var prefix = str.slice(0, pathSepIdx);

    var prefixArr = prefix.split(":");
    this.scheme = prefixArr[0];
    this.uid = prefixArr[1];
    this.protocol = prefixArr[2];

    if (pathSepIdx != -1) {
        var suffix = str.slice(pathSepIdx);
        var querySepIdx = suffix.indexOf('?');
        if (querySepIdx == -1) {
            this.path = suffix;
        } else {
            this.path = suffix.slice(0, querySepIdx);
            this.query = suffix.slice(querySepIdx + 1);
        }
    }
    if (this.scheme === undefined || this.uid === undefined || this.protocol === undefined) {
        throw new Error('Tried to create URI from wrongly formatted string');
    }

    return this;
};

BopURI.prototype = {};

if (typeof(module) !== 'undefined') {
    module.exports = BopURI;
}

},{}],4:[function(require,module,exports){
var ChordNode = require('./node.js');

/** @fileOverview Chord DHT implementation */

/**
 * @constructor
 * @class This is a Chord DHT implementation using WebRTC data channels.
 *
 * @param connectionManager {ConnectionManager} The connection manager instance
 * to be used for requesting data channel connections.
 */
var Chord = function(connectionManager, hash, keyLength) {
    if (!(this instanceof Chord)) {
        return new Chord(connectionManager, hash, keyLength);
    }

    // TODO(max): externalize this so Node can reuse it upon (de-)serializing
    hash.update(Math.random().toString());
    var digest = hash.digest();

    this._connectionManager = connectionManager;
    this._id = hash.bigInteger(digest);
    this._fingerTable = {};
    this._m = keyLength;
    this._joined = false; // are we joined to a Chord ring, yet?
    this._localNode = new ChordNode(new Peer(this._id, null, {
        send: this._onmessage
    }), this);

    var memoizer = Helper.memoize(Helper.fingerTableIntervalStart.bind(this));
    for (var i = 1; i <= this._m; i++) {
        this._fingerTable[i] = {
            start: memoizer.bind(null, i),
            node: this._localNode
        };
    }

    return this;
};

/**
 * Internal Helper Functions
 **/

var Helper = {
    memoize: function(func) {
        var memo = {};
        var slice = Array.prototype.slice;
        return function() {
            var args = slice.call(arguments);
            if (!(args in memo)) {
                memo[args] = func.apply(this, args);
            }
            return memo[args];
        };
    },

    fingerTableIntervalStart: function(i) {
        return this._id.add(BigInt(2).pow(i - 1)).mod(BigInt(2).pow(this._m));
    },

    /**
     * [start, end)
     */
    inInterval: function(val, start, end) {
        return val.greaterOrEquals(start) && val.lesser(end);
    },

    /**
     * (start, end)
     */
    inOpenInterval: function(val, start, end) {
        return val.greater(start) && val.lesser(end);
    }
};

/**
 * Internal API
 **/

Chord.prototype._init_finger_table = function(remote, successCallback) {
    remote.find_successor(this._fingerTable[1].start, function(successor) {
        this._fingerTable[1].node = successor;
        this._predecessor = successor.predecessor;
        this._successor.predecessor = this._localNode;
        successCallback();
    });
};

Chord.prototype._onmessage = function(msg) {
    try {
        this._forward(JSON.parse(msg.data));
    } catch (e) {
        console.log('Unable to parse incoming message ' + JSON.stringify(msg.data) + ': ' + e);
    }
};

Chord.prototype._forward = function(msg) {
    if (!msg.to) {
        throw Error('Unable to route message because no recipient can be determined');
    }
    if (this._id === msg.to) {
        this.deliver(msg);
        return;
    }

    // TODO: fill in magic here (eval via field, route forward via DHT)
};

Chord.prototype._update_others = function() {
    // TODO(max) implement
};

Chord.prototype._closest_preceding_finger = function(id) {
    var i;
    for (i = this._m; i >= 1; i--) {
        if (Helper.inOpenInterval(this._fingerTable[i].node._id, this._id, id)) {
            return this._fingerTable[i].node;
        }
    }
    return this._localNode;
};

/**
 * Public API
 **/

/**
 *
 *
 * @param dc DataChannel connection to remote peer
 */
Chord.prototype.add_peer = function(dc) {};

/**
 * join the DHT by using the 'bootstrap' node
 *
 * @param bootstrap {ChordNode} instance of the bootstrap host
 * @param successCallback {Chord~joinCallback} called after the join operation has been
 * carried out successfully.
 */
Chord.prototype._join = function(bootstrap, successCallback) {
    var i;
    // TODO: implement
    bootstrap.get_node_id(function() {
        this._init_finger_table(bootstrapNode, function() {
            this._update_others();
            // move keys in (predecessor,n] from successor
            successCallback();
        });
    });
};

/**
 * Public API
 **/

/**
 *
 *
 * @param dc DataChannel connection to remote peer
 */
Chord.prototype.addPeer = function(peer) {
    var node = new ChordNode(peer, this);
    peer.dataChannel.onmessage = this.onmessage.bind(this);
    // TODO: implement removing peer/updating finger table
    peer.peerConnection.onclosedconnection = this.removePeer.bind(this, peer);
    if (!this._joined) {
        this._join(node, function() {
            this._joined = true;
        });
        return;
    }
    // TODO: update finger table
};

/**
 * Store 'value' under 'key' in the DHT
 *
 * @param key
 * @param value
 */
Chord.prototype.put = function(key, value) {
    // TODO: implement
};

Chord.prototype.remove = function(key) {
    // TODO: implement
};

Chord.prototype.get = function(key) {
    // TODO: implement
};

if (typeof(module) !== 'undefined') {
    module.exports = Chord;
}

/**
 * Invoked after the node has joined the DHT.
 * @callback Chord~joinCallback
 * @param id {Number} This node's Chord ID.
 */

},{"./node.js":5}],5:[function(require,module,exports){
ChordNode = function(peer, chord) {
    if (!(this instanceof ChordNode)) {
        return new ChordNode(peer, chord);
    }

    this._peer = peer;
    this._successor = null;
    this._predecessor = null;
    this._chord = chord;
    this._pending = {};
    this._seqnr = 0;

    this._chord.registerDeliveryCallback('chord-protocol', this._onmessage.bind(this));

    return this;
};

ChordNode.prototype = {

    /**
     * Public API
     **/

    message_types: {
        FIND_SUCCESSOR: 1,
        SUCCESSOR: 2,
        GET_NODE_ID: 3,
        NODE_ID: 4,
    },

    find_successor: function(id, cb) {
        this._send_request({
            type: this.message_types.FIND_SUCCESSOR,
            id: id.toString()
        }, function(msg) {
            cb(msg.successor);
        });
    },

    get_node_id: function(cb) {
        if (this._id) {
            cb(this._id);
            return;
        }
        this._send_request({
            type: this.message_types.GET_NODE_ID
        }, function(msg) {
            this._id = BigInteger(msg.id); // TODO(max) sanity checks
            cb(this._id);
        }.bind(this));
    },

    /**
     * Internal API
     **/

    _send_successor: function(seqnr) {
        var msg = {
            type: this.message_types.SUCCESSOR,
            successor: this._successor,
            seqnr: seqnr
        };
        this._send(msg);
    },

    _send_node_id: function(seqnr) {
        var msg = {
            type: this.message_types.NODE_ID,
            id: this._id.toString(),
            seqnr: seqnr
        };
        this._send(msg);
    },

    _send_request: function(msg, cb) {
        msg.seqnr = this._seqnr++; // TODO(max): handle overflows
        this._pending[msg.seqnr] = cb;
        this._send(msg);
    },

    _send: function(msg) {
        this._chord.route(this._peer.id, 'chord-protocol', msg);
    },

    _onmessage: function(msg, sender) {
        var cb = this._pending[msg.seqnr];
        // if we find a callback this message is a response to a request of ours
        if (typeof(cb) === 'function') {
            this._handle_response(msg, cb);
        } else {
            this._handle_request(msg);
        }
    },

    _handle_response: function(msg, callback) {
        delete this._pending[msg.seqnr];
        callback(msg);
    },

    _handle_request: function(msg) {
        if (typeof(msg.seqnr) === "undefined") {
            return; // ignore message without sequence number
        }
        switch (msg.type) {
            case this.message_types.FIND_SUCCESSOR:
                this._send_successor(msg.seqnr);
                break;
            case this.message_types.GET_NODE_ID:
                this._send_node_id(msg.seqnr);
                break;
            default:
                //unknown request
                break;
        }
    },

};


if (typeof(module) !== 'undefined') {
    module.exports = ChordNode;
}

},{}],6:[function(require,module,exports){
/** @fileOverview Mid-level connection broking and signaling functionality. */

var Peer = require('./peer.js');

/**
 * @constructor
 * @class Handles the connection establishment to other nodes as
 * well as joining a network (bootstrapping).
 */
var ConnectionManager = function() {
    if (!(this instanceof ConnectionManager)) {
        return new ConnectionManager();
    }
    this._bootstrap = null;
    this._pending = {};
    this._connections = {};
    this._pcoptions = {
        iceServers: [{
            "url": "stun:stun.l.google.com:19302"
        }]
    };
    //possible states: 'uninitialized', 'bootstrapping', 'ready'
    this._state = 'uninitialized';

    return this;
};

ConnectionManager.prototype = {

    utils: {
        /**
         * Returns a list of field values of the given field in the given SDP.
         */
        findInSDP: function(sdp, field) {
            var result = [];
            sdp.split('\r\n').forEach(function(line) {
                if (line.match(new RegExp("^" + field + "="))) {
                    result.push(line.split("=", 2)[1]);
                }
            });
            return result;
        },

        /**
         * Returns the session ID contained in the given SDP. This ID is used
         * for glare handling.
         */
        findSessionId: function(sdp) {
            return parseInt(this.findInSDP(sdp, "o")[0].split(" ")[1], 10);
        },
    },

    /**
     * Connects this instance to the P2P network by establishing a DataChannel
     * connection to an arbitrary peer.
     *
     * @param router {Router} used for delivering the initial offer.
     * @param successCallback {Function} called when a connection has been established
     * and the peer is ready to send/receive data.
     * @param errorCallback {Function} called when the connection could not be
     * established.
     */
    bootstrap: function(router, successCallback, errorCallback) {
        if (this._state !== 'uninitialized') {
            errorCallback('Invalid state');
            return;
        }
        this._state = 'bootstrapping';
        this._router = router;
        var pc = new RTCPeerConnection(this._pcoptions);
        var to = '*';
        this._bootstrap = {
            pc: pc,
            dc: pc.createDataChannel(null, {}),
            onsuccess: successCallback,
            onerror: errorCallback,
        };
        router.registerDeliveryCallback('signaling-protocol', this._onMessage.bind(this));
        pc.createOffer(this._onCreateOfferSuccess.bind(this, pc, to, this._bootstrap, errorCallback),
            this._onCreateOfferError.bind(this, errorCallback));
    },

    /**
     * Creates a DataChannel connection to the given peer.
     *
     * @param to ID of the remote peer
     * @param successCallback {Function} called when the connection has been
     * established
     * @param errorCallback {Function} called when the connection establishment
     * failed
     */
    connect: function(to, successCallback, errorCallback) {
        if (this._state !== 'ready') {
            errorCallback('Invalid state');
            return;
        }
        if (this._pending[to] !== undefined) {
            errorCallback('Already connecting');
        }
        var pc = new RTCPeerConnection(this._pcoptions);
        var dc = pc.createDataChannel(null, {});
        this._pending[to] = {
            pc: pc,
            dc: dc,
            onsuccess: successCallback,
            onerror: errorCallback,
        };
        pc.createOffer(this._onCreateOfferSuccess.bind(this, pc, to, this._pending[to],
            errorCallback), this._onCreateOfferError.bind(this, errorCallback));
    },

    _onCreateOfferSuccess: function(pc, to, pendingOffer, errorCallback, sessionDesc) {
        if (pendingOffer.drop) {
            return;
        }
        pc.onicecandidate = function(iceEvent) {
            if (pc.iceGatheringState === 'complete' || iceEvent.candidate === null) {
                // spec specifies that a null candidate means that the ice gathering is complete
                pc.onicecandidate = function() {};
                pc.createOffer(function(offer) {
                    this._router.route(to, 'signaling-protocol', offer);
                }.bind(this), this._onCreateOfferError.bind(this, errorCallback));
            }
        }.bind(this);
        pendingOffer.offerId = this.utils.findSessionId(sessionDesc.sdp);
        pc.setLocalDescription(sessionDesc);
    },

    _onCreateOfferError: function(errorCallback, error) {
        // TODO(max): clean up state (delete PC object etc.)
        errorCallback(error);
    },

    _onMessage: function(msg, from) {
        switch (msg.type) {
            case 'offer':
                this._onReceiveOffer(msg, from);
                break;
            case 'answer':
                this._onReceiveAnswer(msg, from);
                break;
            case 'denied':
                this._onOfferDenied(msg, from);
                break;
            default:
                console.log('ConnectionManager: Discarding JSEP message because the type is unknown: ' + JSON.stringify(msg));
        }
    },

    _onReceiveAnswer: function(desc, from) {
        if (this._state === 'bootstrapping') {
            // TODO(max): check if we actually have a pending PC and ``drop'' is not set (glare).
            this._bootstrap.pc.setRemoteDescription(new RTCSessionDescription(desc));
            this._bootstrap.dc.onopen = function(ev) {
                // nodejs wrtc-library does not include a channel reference in `ev.target`
                this._router.addPeer(new Peer(from, this._bootstrap.pc, this._bootstrap.dc));
                this._state = 'ready';
                this._bootstrap.onsuccess();
                this._bootstrap = null;
            }.bind(this);
        } else {
            var pending = this._pending[from];
            if (pending === undefined) {
                return; // we haven't offered to this node, silently discard
            }
            pending.pc.setRemoteDescription(new RTCSessionDescription(desc));
            pending.dc.onopen = function(ev) {
                // nodejs wrtc-library does not include a channel reference in `ev.target`
                var peer = new Peer(from, pending.pc, pending.dc);
                this._router.addPeer(peer);
                if (typeof(pending.onsuccess) === 'function') {
                    // TODO(max): would it make sense to pass the remote peer's
                    // ID to the handler?
                    pending.onsuccess();
                }
                delete this._pending[from];
                this._connections[from] = peer;
            }.bind(this);
        }
    },

    _onReceiveOffer: function(desc, from) {
        // if we're already connected or are already processing an offer from
        // this peer, deny this offer
        if (this._connections[from] !== undefined || this._pending[from] !== undefined) {
            this._router.route(from, 'signaling-protocol', {
                type: 'denied'
            });
        }

        var offerId = this.utils.findSessionId(desc.sdp);

        if (this._state === 'bootstrapping') {
            if (this._bootstrap.pc.remoteDescription !== null) {
                // we already have a bootstrap peer
                return;
            }
            if (offerId > this._bootstrap.offerId) {
                // discard our offer and accept this one
                var newBootstrap = {
                    pc: new RTCPeerConnection(this._pcoptions),
                    onsuccess: this._bootstrap.onsuccess,
                    onerror: this._bootstrap.onerror,
                };
                // cancel all actions on the old object
                // FIXME(max): setting ``drop'' here makes no sense since it's overwritten in the next line.
                this._bootstrap.drop = true;
                this._bootstrap = newBootstrap;
            } else {
                // silently discard this offer
                return;
            }
            this._bootstrap.pc.setRemoteDescription(new RTCSessionDescription(desc));
            this._bootstrap.pc.ondatachannel = function(ev) {
                ev.channel.onopen = function(ev2) {
                    // nodejs wrtc-library does not include a channel reference in `ev2.target`
                    var peer = new Peer(from, this._bootstrap.pc, ev.channel);
                    this._router.addPeer(peer);
                    this._state = 'ready';
                    this._bootstrap.onsuccess();
                    this._connections[from] = peer;
                    this._bootstrap = null;
                }.bind(this);
            }.bind(this);
            this._bootstrap.pc.createAnswer(this._onCreateAnswerSuccess.bind(this, from, this._bootstrap.pc), this._onCreateAnswerError.bind(this));
        } else {
            var pendingOffer = this._pending[from];
            if (pendingOffer !== undefined) {
                // handle glare
                if (offerId > pendingOffer.offerId) {
                    // discard our offer and accept this one
                    newPendingOffer = {
                        onsuccess: pendingOffer.onsuccess,
                        onerror: pendingOffer.onerror,
                    };
                    pendingOffer = newPendingOffer;
                    delete this._pending[from];
                } else {
                    // silently discard this offer
                    return;
                }
            }
            var pc = new RTCPeerConnection(this._pcoptions);
            pc.setRemoteDescription(new RTCSessionDescription(desc));
            this._pending[from] = pendingOffer || {};
            this._pending[from].pc = pc;
            pc.ondatachannel = function(ev) {
                ev.channel.onopen = function(ev2) {
                    // nodejs wrtc-library does not include a channel reference in `ev2.target`
                    var peer = new Peer(from, pc, ev.channel);
                    this._router.addPeer(peer);
                    if (typeof(this._pending[from].onsuccess) === 'function') {
                        this._pending[from].onsuccess();
                    }
                    delete this._pending[from];
                    this._connections[from] = peer;
                }.bind(this);
            }.bind(this);
            pc.createAnswer(this._onCreateAnswerSuccess.bind(this, from, pc), this._onCreateAnswerError.bind(this));
        }
    },

    _onCreateAnswerSuccess: function(to, pc, sessionDesc) {
        pc.onicecandidate = function(iceEvent) {
            if (pc.iceGatheringState === 'complete' || iceEvent.candidate === null) {
                // spec specifies that a null candidate means that the ice gathering is complete
                pc.onicecandidate = function() {};
                pc.createAnswer(function(answer) {
                    this._router.route(to, 'signaling-protocol', answer);
                }.bind(this), this._onCreateAnswerError.bind(this));
            }
        }.bind(this);
        pc.setLocalDescription(new RTCSessionDescription(sessionDesc));
    },

    _onCreateAnswerError: function(error) {
        console.log(error);
    },

    /**
     * The server denies offers when only one peer is connected since there is
     * no other peer that could answer the offer. In that case the first peer
     * just has to sit and wait for an offer. Eventually the successCallback is
     * called.
     */
    _onOfferDenied: function(desc) {
        if (this._state === 'bootstrapping') {
            this._bootstrap.pc = new RTCPeerConnection(this._pcoptions);
            this._bootstrap.dc = this._bootstrap.pc.createDataChannel(null, {});
            this._bootstrap.offerId = null;
            this._bootstrap.onsuccess();
            this._bootstrap.onsuccess = function() {};
        }
    },

};

if (typeof(module) !== 'undefined') {
    module.exports = ConnectionManager;
}

},{"./peer.js":7}],7:[function(require,module,exports){
/** @fileOverview Represents a Peer in the network */

/**
 * @constructor
 * @class Represents a foreign Peer. Used by {@link Router} instances to route
 * messages from one Peer to another. Control over a Peer lies in the hand of a
 * {@link ConnectionManager} instance.
 *
 * @param id {String}
 * @param peerConnection {RTCPeerConnection} The PeerConnection to the remote peer.
 * @param dataChannel {DataChannel} The DataChannel to the remote peer.
 */
var Peer = function(id, peerConnection, dataChannel) {
    if (!(this instanceof Peer)) {
        return new Peer(id, peerConnection, dataChannel);
    }
    this.id = id;
    this.peerConnection = peerConnection;
    this.dataChannel = dataChannel;
};

if (typeof(module) !== 'undefined') {
    module.exports = Peer;
}

},{}],8:[function(require,module,exports){
/** @fileOverview Routing functionality */

var Peer = require('./peer.js');

/**
 * @constructor
 * @class The main routing class. Used by {@link ConnectionManager} instances to route
 * messages through the user network.
 *
 * @param id ID of the local peer
 * @param fallbackSignaling
 */
var Router = function(id, fallbackSignaling, connectionManager) {
    if (!(this instanceof Router)) {
        return new Router();
    }

    this._peerTable = {};
    this._fallbackSignaling = fallbackSignaling;
    this._fallbackSignaling.onmessage = this.onmessage.bind(this);
    this._connectionManager = connectionManager;
    this._id = id;
    this._messageCallbacks = {};
    this._monitorCallback = null;
    this.registerDeliveryCallback('discovery', this._onDiscoveryMessage.bind(this));

    return this;
};

Router.prototype = {

    /**
     * Add a peer to the peer table.
     *
     * @param peer {Peer} The peer to add.
     * @todo add test for onclosedconnection behaviour
     */
    addPeer: function(peer) {
        this._peerTable[peer.id] = peer;
        peer.dataChannel.onmessage = this.onmessage.bind(this);
        peer.peerConnection.onclosedconnection = this.removePeer.bind(this, peer);
        if (Object.keys(this._peerTable).length === 1) {
            // ask first peer for its neighbours
            this._discoverNeighbours(peer);
        }
    },

    /**
     * Remove a peer from the peer table.
     *
     * @param peer {Peer} The peer to remove.
     * @todo disconnect peerConnection before removal
     */
    removePeer: function(peer) {
        delete this._peerTable[peer.id];
    },

    /**
     * Return a list of all peer ids currently in the routing table.
     *
     * @returns {Array}
     */
    getPeerIds: function() {
        var peers = [];
        var peer;
        for (peer in this._peerTable) {
            if (this._peerTable.hasOwnProperty(peer)) {
                peers.push(peer);
            }
        }
        return peers;
    },

    onmessage: function(msg) {
        try {
            this.forward(JSON.parse(msg.data));
        } catch (e) {
            console.log('Unable to parse incoming message ' + JSON.stringify(msg.data) + ': ' + e);
        }
    },

    /**
     * Encapsulates message in router format and forwards them.
     *
     * @param to recipient
     * @param type the message type
     * @param payload the message payload
     */
    route: function(to, type, payload) {
        this.forward({
            to: to,
            from: this._id,
            type: type,
            payload: payload
        });
    },

    /**
     * Forward message or deliver if recipient is me. This implementation
     * implies that we are using a fully meshed network where every peer
     * is connected to all other peers.
     *
     * @param msg {String} The message to route.
     */
    forward: function(msg) {
        if (typeof(this._monitorCallback) === 'function') {
            this._monitorCallback(msg);
        }
        if (!msg.to) {
            throw Error('Unable to route message because no recipient can be determined');
        }
        if (this._id === msg.to) {
            this.deliver(msg);
            return;
        }
        var receiver = this._peerTable[msg.to];
        if (!(receiver instanceof Peer)) {
            this._fallbackSignaling.send(JSON.stringify(msg));
            return;
        }
        try {
            receiver.dataChannel.send(JSON.stringify(msg));
        } catch (e) {
            console.log('Unable to route message to ' + msg.to + ' because the DataChannel connection failed.');
        }
    },

    /**
     * Deliver a message to this peer. Is called when the `to` field of
     * the message contains the id of this peer. Decides where to deliver
     * the message to by calling the registered callback using the `type`
     * field (e.g. webrtc connection/ neighbour discovery/ application) of
     * the message.
     *
     * @param msg {String}
     */
    deliver: function(msg) {
        try {
            this._messageCallbacks[msg.type](msg.payload, msg.from);
            //new format:
            //this._messageCallbacks[msg.type]('bop://user@example.org', msg.from, msg.payload);
        } catch (e) {
            console.log('Unable to handle message of type ' + msg.type + ' from ' + msg.from + ' because no callback is registered: ' + e);
        }
    },

    /**
     * Register a delivery callback. The registered callback gets
     * called when a specific type of message arrives with the `from`
     * field set to this peers' id.
     *
     * @param msgType {String} refers to the `type`-field of the message
     * this callback should respond to
     * @param callback {Function} The callback to call when a message of
     * the given type arrives
     */
    registerDeliveryCallback: function(msgType, callback) {
        this._messageCallbacks[msgType] = callback;
    },

    /**
     * Register a monitor callback. The registered callback gets
     * called when a message arrives with the `from` field set to
     * this peers' id.
     *
     * @param callback {Function} The callback to call when a message is delivered
     */
    registerMonitorCallback: function(callback) {
        this._monitorCallback = callback;
    },

    /**
     * Kick off neighbour discovery mechanism by sending a `discovery-request' message to
     * a connected peer.
     *
     * @param peer {Peer}
     * @todo implement
     */
    _discoverNeighbours: function(peer) {
        this.route(peer.id, 'discovery', {
            type: 'request'
        });
    },

    _onDiscoveryMessage: function(msg, from) {
        switch (msg.type) {
            case 'answer':
                this._processDiscoveryAnswer(msg, from);
                break;
            case 'request':
                this._processDiscoveryRequest(msg, from);
                break;
            default:
                console.log('Router: received invalid discovery message with type %s from %s', msg.type, from);
                break;
        }
    },

    /**
     * Gets called when a neighbour discovery answer message is received.
     *
     * @param msg {String} Message containing ids of another peers peer table.
     * @todo should this call the connection manager?
     */
    _processDiscoveryAnswer: function(msg, from) {
        var i, ids = msg.ids;
        for (i = 0; i < ids.length; i++) {
            if (ids[i] !== this._id) {
                this._connectionManager.connect(ids[i]);
            }
        }
    },

    /**
     * Answer a received neighbour discovery message. Respond with
     * known ids of all peers in the peerTable.
     *
     * @param msg {String} Message containing the discovery request from another peer.
     * @todo discovery message format
     */
    _processDiscoveryRequest: function(msg, from) {
        var peerIds = [],
            peer;
        for (peer in this._peerTable) {
            if (this._peerTable.hasOwnProperty(peer) && this._peerTable[peer] instanceof Peer) {
                peerIds.push(peer);
            }
        }
        this.route(from, 'discovery', {
            type: 'answer',
            ids: peerIds
        });
    }
};

if (typeof(module) !== 'undefined') {
    module.exports = Router;
}

},{"./peer.js":7}],9:[function(require,module,exports){
var bigInt = (function() {
    var base = 10000000,
        logBase = 7;
    var sign = {
        positive: false,
        negative: true
    };

    var normalize = function(first, second) {
        var a = first.value,
            b = second.value,
            i;
        var length = a.length > b.length ? a.length : b.length;
        for (i = 0; i < length; i++) {
            a[i] = a[i] || 0;
            b[i] = b[i] || 0;
        }
        for (i = length - 1; i >= 0; i--) {
            if (a[i] === 0 && b[i] === 0) {
                a.pop();
                b.pop();
            } else {
                break;
            }
        }
        if (!a.length) {
            a = [0];
            b = [0];
        }
        first.value = a;
        second.value = b;
    };

    var parse = function(text, first) {
        if (typeof text === "object") {
            return text;
        }
        text += "";
        var s = sign.positive,
            value = [];
        if (text[0] === "-") {
            s = sign.negative;
            text = text.slice(1);
        }
        text = text.split("e");
        if (text.length > 2) {
            throw new Error("Invalid integer");
        }
        if (text[1]) {
            var exp = text[1];
            if (exp[0] === "+") {
                exp = exp.slice(1);
            }
            exp = parse(exp);
            if (exp.lesser(0)) {
                throw new Error("Cannot include negative exponent part for integers");
            }
            while (exp.notEquals(0)) {
                text[0] += "0";
                exp = exp.prev();
            }
        }
        text = text[0];
        if (text === "-0") {
            text = "0";
        }
        var isValid = /^([0-9][0-9]*)$/.test(text);
        if (!isValid) {
            throw new Error("Invalid integer");
        }
        while (text.length) {
            var divider = text.length > logBase ? text.length - logBase : 0;
            value.push(+text.slice(divider));
            text = text.slice(0, divider);
        }
        var val = bigInt(value, s);
        if (first) {
            normalize(first, val);
        }
        return val;
    };

    var goesInto = function(a, b) {
        a = bigInt(a, sign.positive);
        b = bigInt(b, sign.positive);
        if (a.equals(0)) {
            throw new Error("Cannot divide by 0");
        }
        var n = 0;
        do {
            var inc = 1;
            var c = bigInt(a.value, sign.positive),
                t = c.times(10);
            while (t.lesser(b)) {
                c = t;
                inc *= 10;
                t = t.times(10);
            }
            while (c.lesserOrEquals(b)) {
                b = b.minus(c);
                n += inc;
            }
        } while (a.lesserOrEquals(b));

        return {
            remainder: b.value,
            result: n
        };
    };

    var bigInt = function(value, s) {
        var self = {
            value: value,
            sign: s
        };
        var o = {
            value: value,
            sign: s,
            negate: function(m) {
                var first = m || self;
                return bigInt(first.value, !first.sign);
            },
            abs: function(m) {
                var first = m || self;
                return bigInt(first.value, sign.positive);
            },
            add: function(n, m) {
                var s, first = self,
                    second;
                if (m) {
                    first = parse(n);
                    second = parse(m);
                } else {
                    second = parse(n, first);
                }
                s = first.sign;
                if (first.sign !== second.sign) {
                    first = bigInt(first.value, sign.positive);
                    second = bigInt(second.value, sign.positive);
                    return s === sign.positive ?
                        o.subtract(first, second) :
                        o.subtract(second, first);
                }
                normalize(first, second);
                var a = first.value,
                    b = second.value;
                var result = [],
                    carry = 0;
                for (var i = 0; i < a.length || carry > 0; i++) {
                    var sum = (a[i] || 0) + (b[i] || 0) + carry;
                    carry = sum >= base ? 1 : 0;
                    sum -= carry * base;
                    result.push(sum);
                }
                return bigInt(result, s);
            },
            plus: function(n, m) {
                return o.add(n, m);
            },
            subtract: function(n, m) {
                var first = self,
                    second;
                if (m) {
                    first = parse(n);
                    second = parse(m);
                } else {
                    second = parse(n, first);
                }
                if (first.sign !== second.sign) {
                    return o.add(first, o.negate(second));
                }
                if (first.sign === sign.negative) {
                    return o.subtract(o.negate(second), o.negate(first));
                }
                if (o.compare(first, second) === -1) {
                    return o.negate(o.subtract(second, first));
                }
                var a = first.value,
                    b = second.value;
                var result = [],
                    borrow = 0;
                for (var i = 0; i < a.length; i++) {
                    var tmp = a[i] - borrow;
                    borrow = tmp < b[i] ? 1 : 0;
                    var minuend = (borrow * base) + tmp - b[i];
                    result.push(minuend);
                }
                return bigInt(result, sign.positive);
            },
            minus: function(n, m) {
                return o.subtract(n, m);
            },
            multiply: function(n, m) {
                var s, first = self,
                    second, k;
                if (m) {
                    first = parse(n);
                    second = parse(m);
                } else {
                    second = parse(n, first);
                }
                s = first.sign !== second.sign;
                var a = first.value,
                    b = second.value;
                var resultSum = [];
                for (var i = 0; i < a.length; i++) {
                    resultSum[i] = [];
                    var j = i;
                    while (j--) {
                        resultSum[i].push(0);
                    }
                }
                var carry = 0;
                for (i = 0; i < a.length; i++) {
                    var x = a[i];
                    for (k = 0; k < b.length || carry > 0; k++) {
                        var y = b[k];
                        var product = y ? (x * y) + carry : carry;
                        carry = product > base ? Math.floor(product / base) : 0;
                        product -= carry * base;
                        resultSum[i].push(product);
                    }
                }
                var max = -1;
                for (i = 0; i < resultSum.length; i++) {
                    var len = resultSum[i].length;
                    if (len > max) {
                        max = len;
                    }
                }
                var result = [];
                carry = 0;
                for (i = 0; i < max || carry > 0; i++) {
                    var sum = carry;
                    for (k = 0; k < resultSum.length; k++) {
                        sum += resultSum[k][i] || 0;
                    }
                    carry = sum > base ? Math.floor(sum / base) : 0;
                    sum -= carry * base;
                    result.push(sum);
                }
                return bigInt(result, s);
            },
            times: function(n, m) {
                return o.multiply(n, m);
            },
            divmod: function(n, m) {
                var s, first = self,
                    second;
                if (m) {
                    first = parse(n);
                    second = parse(m);
                } else {
                    second = parse(n, first);
                }
                s = first.sign !== second.sign;
                if (bigInt(first.value, first.sign).equals(0)) {
                    return {
                        quotient: bigInt([0], sign.positive),
                        remainder: bigInt([0], sign.positive)
                    };
                }
                if (second.equals(0)) {
                    throw new Error("Cannot divide by zero");
                }
                var a = first.value,
                    b = second.value;
                var result = [],
                    remainder = [];
                for (var i = a.length - 1; i >= 0; i--) {
                    n = [a[i]].concat(remainder);
                    var quotient = goesInto(b, n);
                    result.push(quotient.result);
                    remainder = quotient.remainder;
                }
                result.reverse();
                return {
                    quotient: bigInt(result, s),
                    remainder: bigInt(remainder, first.sign)
                };
            },
            divide: function(n, m) {
                return o.divmod(n, m).quotient;
            },
            over: function(n, m) {
                return o.divide(n, m);
            },
            mod: function(n, m) {
                return o.divmod(n, m).remainder;
            },
            pow: function(n, m) {
                var first = self,
                    second;
                if (m) {
                    first = parse(n);
                    second = parse(m);
                } else {
                    second = parse(n, first);
                }
                var a = first,
                    b = second;
                if (b.lesser(0)) {
                    return ZERO;
                }
                if (b.equals(0)) {
                    return ONE;
                }
                var result = bigInt(a.value, a.sign);

                if (b.mod(2).equals(0)) {
                    var c = result.pow(b.over(2));
                    return c.times(c);
                } else {
                    return result.times(result.pow(b.minus(1)));
                }
            },
            next: function(m) {
                var first = m || self;
                return o.add(first, 1);
            },
            prev: function(m) {
                var first = m || self;
                return o.subtract(first, 1);
            },
            compare: function(n, m) {
                var first = self,
                    second;
                if (m) {
                    first = parse(n);
                    second = parse(m, first);
                } else {
                    second = parse(n, first);
                }
                normalize(first, second);
                if (first.value.length === 1 && second.value.length === 1 && first.value[0] === 0 && second.value[0] === 0) {
                    return 0;
                }
                if (second.sign !== first.sign) {
                    return first.sign === sign.positive ? 1 : -1;
                }
                var multiplier = first.sign === sign.positive ? 1 : -1;
                var a = first.value,
                    b = second.value;
                for (var i = a.length - 1; i >= 0; i--) {
                    if (a[i] > b[i]) {
                        return 1 * multiplier;
                    }
                    if (b[i] > a[i]) {
                        return -1 * multiplier;
                    }
                }
                return 0;
            },
            compareAbs: function(n, m) {
                var first = self,
                    second;
                if (m) {
                    first = parse(n);
                    second = parse(m, first);
                } else {
                    second = parse(n, first);
                }
                first.sign = second.sign = sign.positive;
                return o.compare(first, second);
            },
            equals: function(n, m) {
                return o.compare(n, m) === 0;
            },
            notEquals: function(n, m) {
                return !o.equals(n, m);
            },
            lesser: function(n, m) {
                return o.compare(n, m) < 0;
            },
            greater: function(n, m) {
                return o.compare(n, m) > 0;
            },
            greaterOrEquals: function(n, m) {
                return o.compare(n, m) >= 0;
            },
            lesserOrEquals: function(n, m) {
                return o.compare(n, m) <= 0;
            },
            isPositive: function(m) {
                var first = m || self;
                return first.sign === sign.positive;
            },
            isNegative: function(m) {
                var first = m || self;
                return first.sign === sign.negative;
            },
            isEven: function(m) {
                var first = m || self;
                return first.value[0] % 2 === 0;
            },
            isOdd: function(m) {
                var first = m || self;
                return first.value[0] % 2 === 1;
            },
            toString: function(m) {
                var first = m || self;
                var str = "",
                    len = first.value.length;
                while (len--) {
                    if (first.value[len].toString().length === 8) {
                        str += first.value[len];
                    } else {
                        str += (base.toString() + first.value[len]).slice(-logBase);
                    }
                }
                while (str[0] === "0") {
                    str = str.slice(1);
                }
                if (!str.length) {
                    str = "0";
                }
                var s = first.sign === sign.positive ? "" : "-";
                return s + str;
            },
            toJSNumber: function(m) {
                return +o.toString(m);
            },
            valueOf: function(m) {
                return o.toJSNumber(m);
            }
        };
        return o;
    };

    var ZERO = bigInt([0], sign.positive);
    var ONE = bigInt([1], sign.positive);
    var MINUS_ONE = bigInt([1], sign.negative);

    var fnReturn = function(a) {
        if (typeof a === "undefined") {
            return ZERO;
        }
        return parse(a);
    };
    fnReturn.zero = ZERO;
    fnReturn.one = ONE;
    fnReturn.minusOne = MINUS_ONE;
    return fnReturn;
})();

if (typeof module !== "undefined") {
    module.exports = bigInt;
}

},{}],10:[function(require,module,exports){
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */

var BigInteger = require('./BigInteger');

/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 */
var sha1 = function() {

    /**
     * Holds the previous values of accumulated variables a-e in the compress_
     * function.
     * @type {Array.<number>}
     * @private
     */
    this.chain_ = [];

    /**
     * A buffer holding the partially computed hash result.
     * @type {Array.<number>}
     * @private
     */
    this.buf_ = [];

    /**
     * An array of 80 bytes, each a part of the message to be hashed.  Referred to
     * as the message schedule in the docs.
     * @type {Array.<number>}
     * @private
     */
    this.W_ = [];

    /**
     * Contains data needed to pad messages less than 64 bytes.
     * @type {Array.<number>}
     * @private
     */
    this.pad_ = [];

    this.pad_[0] = 128;
    for (var i = 1; i < 64; ++i) {
        this.pad_[i] = 0;
    }

    this.reset();
};


/** @override */
sha1.prototype.reset = function() {
    this.chain_[0] = 0x67452301;
    this.chain_[1] = 0xefcdab89;
    this.chain_[2] = 0x98badcfe;
    this.chain_[3] = 0x10325476;
    this.chain_[4] = 0xc3d2e1f0;

    this.inbuf_ = 0;
    this.total_ = 0;
};


/**
 * Internal compress helper function.
 * @param {Array.<number>|Uint8Array|string} buf Block to compress.
 * @param {number=} opt_offset Offset of the block in the buffer.
 * @private
 */
sha1.prototype.compress_ = function(buf, opt_offset) {
    if (!opt_offset) {
        opt_offset = 0;
    }

    var W = this.W_,
        i, t;

    // get 16 big endian words
    if (typeof(buf) === 'string') {
        for (i = 0; i < 16; i++) {
            W[i] = (buf.charCodeAt(opt_offset++) << 24) |
                (buf.charCodeAt(opt_offset++) << 16) |
                (buf.charCodeAt(opt_offset++) << 8) |
                (buf.charCodeAt(opt_offset++));
        }
    } else {
        for (i = 0; i < 16; i++) {
            W[i] = (buf[opt_offset++] << 24) |
                (buf[opt_offset++] << 16) |
                (buf[opt_offset++] << 8) |
                (buf[opt_offset++]);
        }
    }

    // expand to 80 words
    for (i = 16; i < 80; i++) {
        t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
        W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
    }

    var a = this.chain_[0];
    var b = this.chain_[1];
    var c = this.chain_[2];
    var d = this.chain_[3];
    var e = this.chain_[4];
    var f, k;

    // TODO(user): Try to unroll this loop to speed up the computation.
    for (i = 0; i < 80; i++) {
        if (i < 40) {
            if (i < 20) {
                f = d ^ (b & (c ^ d));
                k = 0x5a827999;
            } else {
                f = b ^ c ^ d;
                k = 0x6ed9eba1;
            }
        } else {
            if (i < 60) {
                f = (b & c) | (d & (b | c));
                k = 0x8f1bbcdc;
            } else {
                f = b ^ c ^ d;
                k = 0xca62c1d6;
            }
        }

        t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
        e = d;
        d = c;
        c = ((b << 30) | (b >>> 2)) & 0xffffffff;
        b = a;
        a = t;
    }

    this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
    this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
    this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
    this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
    this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
};


/** @override */
sha1.prototype.update = function(bytes, opt_length) {
    if (opt_length === undefined) {
        opt_length = bytes.length;
    }

    var lengthMinusBlock = opt_length - 64;
    var n = 0;
    // Using local instead of member variables gives ~5% speedup on Firefox 16.
    var buf = this.buf_;
    var inbuf = this.inbuf_;

    // The outer while loop should execute at most twice.
    while (n < opt_length) {
        // When we have no data in the block to top up, we can directly process the
        // input buffer (assuming it contains sufficient data). This gives ~25%
        // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
        // the data is provided in large chunks (or in multiples of 64 bytes).
        if (inbuf === 0) {
            while (n <= lengthMinusBlock) {
                this.compress_(bytes, n);
                n += 64;
            }
        }

        if (typeof(bytes) === 'string') {
            while (n < opt_length) {
                buf[inbuf++] = bytes.charCodeAt(n++);
                if (inbuf == 64) {
                    this.compress_(buf);
                    inbuf = 0;
                    // Jump to the outer loop so we use the full-block optimization.
                    break;
                }
            }
        } else {
            while (n < opt_length) {
                buf[inbuf++] = bytes[n++];
                if (inbuf == 64) {
                    this.compress_(buf);
                    inbuf = 0;
                    // Jump to the outer loop so we use the full-block optimization.
                    break;
                }
            }
        }
    }

    this.inbuf_ = inbuf;
    this.total_ += opt_length;
};


/** @override */
sha1.prototype.digest = function() {
    var digest = [];
    var totalBits = this.total_ * 8;

    // Add pad 0x80 0x00*.
    if (this.inbuf_ < 56) {
        this.update(this.pad_, 56 - this.inbuf_);
    } else {
        this.update(this.pad_, 64 - (this.inbuf_ - 56));
    }

    // Add # bits.
    for (var i = 63; i >= 56; i--) {
        this.buf_[i] = totalBits & 255;
        totalBits /= 256; // Don't use bit-shifting here!
    }

    this.compress_(this.buf_);

    var n = 0;
    for (i = 0; i < 5; i++) {
        for (var j = 24; j >= 0; j -= 8) {
            digest[n++] = (this.chain_[i] >> j) & 255;
        }
    }

    return digest;
};

sha1.hexString = function(digest) {
    var res = "",
        i;
    for (i = 0; i < digest.length; i++) {
        res = res.concat(digest[i].toString(16));
    }
    return res;
};

sha1.number = function(digest) {
    var value = 0,
        i;
    for (i = digest.length - 1; i >= 0; i--) {
        value = (value * 256) + digest[i];
    }
    return value;
};

sha1.prototype.bigInteger = function(digest) {
    var value = BigInteger(),
        i;
    for (i = digest.length - 1; i >= 0; i--) {
        value = value.multiply(256).add(digest[i]);
    }
    return value;
};

if (typeof(module) !== 'undefined') {
    module.exports = sha1;
}

},{"./BigInteger":9}],11:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[1,2,3,4,5,6,7,8,9,10])